# CSC120-FinalProject

## Deliverables:
 - Your final codebase
 - Your revised annotated architecture diagram
 - Design justification (including a brief discussion of at least one alternative you considered)
 - A map of your game's layout (if applicable)
 - `cheatsheet.md`
 - Completed `rubric.md`
  
## Additional Reflection Questions
 - What was your **overall approach** to tackling this project?
 - What **new thing(s)** did you learn / figure out in completing this project?
 - Is there anything that you wish you had **implemented differently**?
 - If you had **unlimited time**, what additional features would you implement?
 - What was the most helpful **piece of feedback** you received while working on your project? Who gave it to you?
 - If you could go back in time and give your past self some **advice** about this project, what hints would you give?
 - _If you worked with a team:_ please comment on how your **team dynamics** influenced your experience working on this project.

 ## Design Justification
For this game, I made classes for the rooms and the characters. All the information or items that the characters or rooms have are stored as Strings. I initially considered making a separate item class. However, my concept for the game didn't really require the items to have any methods or attributes beyond a name. For the sake of space, I decided it would be easier to save items as Strings. Rooms and characters however each required a number of methods, which is why I wrote a separate class for each of them. There is also a child class of 'Character' called 'Player', used to store information about the player's character. Since the player needs to be able to move rooms while the rest of the characters should stay in one place, I extended the character class to make the player class and added a method that allows the player to move rooms. Most information in characters and rooms is stored in array lists, since I just needed storage that was easily accessible. Thinking about it now, I probably could have used arrays instead of array lists for most of the storage, since I didn't really need flexible sizing in most cases. However, that wasn't something I considered at the time. In the gameplay class, characters and rooms are stored as values in hashtables and have a string of their name as their key. This was to make it easier to quickly access a character or a room, given only its name. All of the gameplay logic is supported by nested while-loops and if-statements, since that seemed the most straightforward way to obtain the branching I wanted when I was brainstorming. If I had more time, perhaps I might have come up with a more elegant way to complete the design, but I opted for an easier, if slighly messier, approach.

## Reflection
While tackling this project, I first attempted to figure out what elements I would need (ex: rooms, characters, alibis, testimonies, evidence, etc). I then moved on to thinking about what data type would be best for implementing those elements. Next, I considered the gameflow and how I wanted to implement that. And finally, I figured out what story I wanted to tell with all the elements I had. To be honest, I think designing the mystery might have been harder than coming up with the actual code. While working on this project, I learned how to read and write from files and how to store information in a graph, as well as how to use additional libraries in my code. The graph was probably the hardest of the things I learned, because it took me a while to figure out what I could and couldn't do with an immutable graph and how to obtain the data I wanted from the graph once I had built it. I wish I had implemented the gameplay logic a bit differently, so that the user had more options for what to do at a given moment instead of being locked into a fixed cycle of move -> investigate character -> guess murderer. That's definitely something I would change if I had more time. Also, if I had more time, I would've liked to add a feature where characters had information that you couldn't receive until after you've learned something from another character. That was a part of my initial plan for this game, but it never got implemented because I ran out of time. I think the most helpful feedback I got was from someone else in class when we were doing final project review. They didn't understand what some of the functions were supposed to do, and that told me I needed to make my code clearer. If I could give myself some advice, I'd tell myself to start brainstorming the mystery I wanted to implement earlier. I got hung up on some story details at the last minute, which meant I wasn't able to spend time on some of the extra functions I wanted to add.